import { Dependency, VulnerabilityReport, CheckerResult, ParseResult, FileType } from '../types';
import { Logger } from '../utils/logger';
import { OSVService, PyPIAdvisoryService, NpmRegistryService } from '../services';
import * as path from 'path';

export class VulnerabilityChecker {
  private logger: Logger;
  private osvService: OSVService;
  private pypiAdvisoryService: PyPIAdvisoryService;
  private npmRegistryService: NpmRegistryService;

  constructor(logger: Logger) {
    this.logger = logger;
    this.osvService = new OSVService();
    this.pypiAdvisoryService = new PyPIAdvisoryService();
    this.npmRegistryService = new NpmRegistryService();
  }

  async checkDependencies(
    parseResults: ParseResult[], 
    ignoreList?: { cveIds?: string[]; severityIgnore?: string[] }
  ): Promise<CheckerResult> {
    const allDependencies: Dependency[] = [];
    const vulnerabilitiesMap = new Map<string, VulnerabilityReport>();

    // Collect all dependencies
    for (const result of parseResults) {
      allDependencies.push(...result.dependencies);
    }

    this.logger.debug(`Checking ${allDependencies.length} dependencies for vulnerabilities...`);

    // Group dependencies by ecosystem
    const npmPackages: Dependency[] = [];
    const pythonPackages: Dependency[] = [];

    for (const result of parseResults) {
      if (result.fileType === FileType.PACKAGE_JSON || 
          result.fileType === FileType.PACKAGE_LOCK ||
          result.fileType === FileType.YARN_LOCK) {
        npmPackages.push(...result.dependencies);
      } else if (result.fileType === FileType.REQUIREMENTS_TXT || 
                 result.fileType === FileType.PIPFILE_LOCK ||
                 result.fileType === FileType.POETRY_LOCK) {
        pythonPackages.push(...result.dependencies);
      }
    }

    // Check npm packages with multiple sources
    if (npmPackages.length > 0) {
      // Check with npm Registry API
      this.logger.debug(`Checking ${npmPackages.length} npm packages with npm Registry...`);
      const npmRegistryResults = await this.checkNpmPackagesRegistry(npmPackages);
      this.logger.debug(`npm Registry found ${npmRegistryResults.length} vulnerabilities`);
      for (const vuln of npmRegistryResults) {
        // Use CVE ID if available, otherwise use description for uniqueness
        const uniqueId = vuln.cveIds.length > 0 
          ? vuln.cveIds.sort().join(',') 
          : vuln.description.substring(0, 100);
        const key = `${vuln.package}@${vuln.version}:${uniqueId}`;
        this.logger.debug(`  - ${vuln.package}@${vuln.version}: ${vuln.severity} - ${vuln.description.substring(0, 60)}...`);
        if (!vulnerabilitiesMap.has(key)) {
          vulnerabilitiesMap.set(key, vuln);
        }
      }

      // Check with OSV.dev
      this.logger.debug(`Checking ${npmPackages.length} npm packages with OSV.dev...`);
      const osvResults = await this.checkNpmPackagesOSV(npmPackages);
      this.logger.debug(`OSV.dev found ${osvResults.length} vulnerabilities`);
      for (const vuln of osvResults) {
        // Use CVE ID if available, otherwise use description for uniqueness
        const uniqueId = vuln.cveIds.length > 0 
          ? vuln.cveIds.sort().join(',') 
          : vuln.description.substring(0, 100);
        const key = `${vuln.package}@${vuln.version}:${uniqueId}`;
        this.logger.debug(`  - ${vuln.package}@${vuln.version}: ${vuln.severity} - ${vuln.description.substring(0, 60)}...`);
        if (!vulnerabilitiesMap.has(key)) {
          vulnerabilitiesMap.set(key, vuln);
        }
      }

    }

    // Check Python packages with OSV
    if (pythonPackages.length > 0) {
      this.logger.debug(`Checking ${pythonPackages.length} Python packages with OSV.dev...`);
      const osvResults = await this.checkPythonPackagesOSV(pythonPackages);
      this.logger.debug(`OSV.dev found ${osvResults.length} vulnerabilities for Python packages`);
      for (const vuln of osvResults) {
        // Use CVE ID if available, otherwise use description for uniqueness
        const uniqueId = vuln.cveIds.length > 0 
          ? vuln.cveIds.sort().join(',') 
          : vuln.description.substring(0, 100);
        const key = `${vuln.package}@${vuln.version}:${uniqueId}`;
        this.logger.debug(`  - ${vuln.package}@${vuln.version}: ${vuln.severity} - ${vuln.description.substring(0, 60)}...`);
        if (!vulnerabilitiesMap.has(key)) {
          vulnerabilitiesMap.set(key, vuln);
        }
      }

      // Check Python packages with PyPI Advisory Database
      this.logger.debug(`Checking ${pythonPackages.length} Python packages with PyPI Advisory Database...`);
      const pypiResults = await this.checkPythonPackagesPyPI(pythonPackages);
      this.logger.debug(`PyPI Advisory Database found ${pypiResults.length} vulnerabilities`);
      for (const vuln of pypiResults) {
        // Use CVE ID if available, otherwise use description for uniqueness
        const uniqueId = vuln.cveIds.length > 0 
          ? vuln.cveIds.sort().join(',') 
          : vuln.description.substring(0, 100);
        const key = `${vuln.package}@${vuln.version}:${uniqueId}`;
        this.logger.debug(`  - ${vuln.package}@${vuln.version}: ${vuln.severity} - ${vuln.description.substring(0, 60)}...`);
        if (!vulnerabilitiesMap.has(key)) {
          vulnerabilitiesMap.set(key, vuln);
        }
      }
    }

    let vulnerabilities = Array.from(vulnerabilitiesMap.values());

    // Apply ignore list if provided
    if (ignoreList) {
      const originalCount = vulnerabilities.length;
      
      vulnerabilities = vulnerabilities.filter(vuln => {
        // Check if any CVE ID matches the ignore list
        if (ignoreList.cveIds && ignoreList.cveIds.length > 0) {
          const hasCVEMatch = vuln.cveIds.some(cveId => 
            ignoreList.cveIds!.includes(cveId)
          );
          if (hasCVEMatch) {
            this.logger.debug(`Ignoring ${vuln.package}@${vuln.version} due to CVE filter: ${vuln.cveIds.join(', ')}`);
            return false;
          }
        }
        
        // Check if severity matches the ignore list
        if (ignoreList.severityIgnore && ignoreList.severityIgnore.length > 0) {
          if (ignoreList.severityIgnore.includes(vuln.severity)) {
            this.logger.debug(`Ignoring ${vuln.package}@${vuln.version} due to severity filter: ${vuln.severity}`);
            return false;
          }
        }
        
        return true;
      });

      const filteredCount = originalCount - vulnerabilities.length;
      if (filteredCount > 0) {
        this.logger.debug(`Filtered out ${filteredCount} vulnerabilities based on ignore list`);
      }
    }

    // Calculate summary statistics
    const summary = {
      critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
      high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
      moderate: vulnerabilities.filter(v => v.severity === 'MODERATE').length,
      low: vulnerabilities.filter(v => v.severity === 'LOW').length,
      unknown: vulnerabilities.filter(v => v.severity === 'UNKNOWN').length
    };

    const vulnerablePackages = new Set(vulnerabilities.map(v => v.package)).size;
    const percentageVulnerable = allDependencies.length > 0 
      ? (vulnerablePackages / allDependencies.length) * 100 
      : 0;

    return {
      totalDependencies: allDependencies.length,
      vulnerabilitiesFound: vulnerabilities.length,
      vulnerablePackages,
      percentageVulnerable: Math.round(percentageVulnerable * 100) / 100,
      vulnerabilities: vulnerabilities.sort((a, b) => {
        const severityOrder = { CRITICAL: 0, HIGH: 1, MODERATE: 2, LOW: 3, UNKNOWN: 4 };
        return severityOrder[a.severity] - severityOrder[b.severity];
      }),
      parseResults,
      summary
    };
  }


  private async checkNpmPackagesRegistry(packages: Dependency[]): Promise<VulnerabilityReport[]> {
    return await this.npmRegistryService.auditDependencies(packages);
  }

  private async checkNpmPackagesOSV(packages: Dependency[]): Promise<VulnerabilityReport[]> {
    // Filter out packages with missing versions and log warnings
    const validPackages = packages.filter(p => {
      if (!p.version || p.version.trim() === '') {
        this.logger.debug(`Skipping ${p.name}: missing version information`);
        return false;
      }
      return true;
    });

    const packagesToCheck = validPackages.map(p => ({
      name: p.name,
      version: p.version.replace(/^[\^~]/, ''), // Remove semver prefixes
      ecosystem: 'npm'
    }));

    return await this.osvService.batchQuery(packagesToCheck);
  }

  private async checkPythonPackagesOSV(packages: Dependency[]): Promise<VulnerabilityReport[]> {
    // Filter out packages with missing versions and log warnings
    const validPackages = packages.filter(p => {
      if (!p.version || p.version.trim() === '') {
        this.logger.debug(`Skipping ${p.name}: missing version information`);
        return false;
      }
      return true;
    });

    const packagesToCheck = validPackages.map(p => ({
      name: p.name,
      version: p.version === 'latest' ? '0.0.0' : p.version,
      ecosystem: 'PyPI'
    }));

    return await this.osvService.batchQuery(packagesToCheck);
  }

  private async checkPythonPackagesPyPI(packages: Dependency[]): Promise<VulnerabilityReport[]> {
    const packagesToCheck = packages
      .filter(p => {
        if (!p.version || p.version.trim() === '' || p.version === 'latest') {
          if (!p.version || p.version.trim() === '') {
            this.logger.debug(`Skipping ${p.name}: missing version information`);
          }
          return false;
        }
        return true;
      })
      .map(p => ({
        name: p.name,
        version: p.version
      }));

    return await this.pypiAdvisoryService.batchCheck(packagesToCheck);
  }

}
